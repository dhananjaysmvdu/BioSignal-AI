name: Audit Provenance History

on:
  schedule:
    - cron: "0 5 * * 0"  # Sundays at 05:00 UTC

jobs:
  audit-history:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq and gnupg
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq gnupg
          jq --version
          gpg --version

      - name: Import badge public key
        id: pubkey
        run: |
          if [ ! -f .github/public_keys/badge_signing.pub ]; then
            echo "Public key not found at .github/public_keys/badge_signing.pub" >&2
            exit 1
          fi
          gpg --import .github/public_keys/badge_signing.pub
          PUB_FPR=$(gpg --show-keys --with-colons .github/public_keys/badge_signing.pub | awk -F: '/^fpr:/{print $10; exit}')
          PUB_FPR_CLEAN=$(echo "$PUB_FPR" | tr -d ' ')
          echo "Imported public key fingerprint: $PUB_FPR"  # full forensics log
          echo "pub_fpr=$PUB_FPR_CLEAN" >> $GITHUB_OUTPUT

      - name: Audit last 10 provenance entries
        id: audit
        env:
          PUB_FPR: ${{ steps.pubkey.outputs.pub_fpr }}
        run: |
          set -e
          if [ ! -f reports/history/versions.json ]; then
            echo "versions.json not found at reports/history/versions.json" >&2
            echo "summary<<EOF" >> $GITHUB_OUTPUT
            echo "No versions.json present; nothing to audit." >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Prepare entries (commit and expected sig hash) from various possible schemas
          mapfile -t ENTRIES < <(jq -r '
            ((.versions // .history // .entries // .) | (if type=="array" then . else [] end))
            | (if length>10 then .[-10:] else . end)
            | map({c: (.commit // .sha // .hash // .rev // .revision // .id), h: (.coverage_badge_hash // .coverageHash // .coverage_sig_sha256)})
            | map(select(.c!=null and .h!=null))
            | .[] | "\(.c) \(.h)"' reports/history/versions.json)

          PASS_CNT=0
          FAIL_CNT=0
          FAIL_LOG=""
          FAIL_COMMITS=""
          CHECKED=${#ENTRIES[@]}

          for line in "${ENTRIES[@]}"; do
            COMMIT=$(echo "$line" | awk '{print $1}')
            EXPECTED=$(echo "$line" | awk '{print $2}')
            echo "\nAuditing commit $COMMIT ..."

            # 1) Verify signature matches imported key
            SIG_OUT=$(git log -1 --show-signature "$COMMIT" 2>&1 || true)
            echo "$SIG_OUT"
            COMMIT_FPR=$(echo "$SIG_OUT" | sed -n -E 's/^gpg: Primary key fingerprint: (.*)/\1/p' | head -n1 | tr -d ' ')
            if [ -z "$COMMIT_FPR" ]; then
              echo "‚ùå No GPG fingerprint found in signature output for $COMMIT"
              FAIL_CNT=$((FAIL_CNT+1))
              FAIL_LOG+="- $COMMIT: missing signature or fingerprint\n"
              FAIL_COMMITS+="$COMMIT\n"
              continue
            fi
            if [ "$COMMIT_FPR" != "$PUB_FPR" ]; then
              echo "‚ùå Fingerprint mismatch: commit uses $COMMIT_FPR, expected $PUB_FPR"
              FAIL_CNT=$((FAIL_CNT+1))
              FAIL_LOG+="- $COMMIT: fingerprint mismatch\n"
              FAIL_COMMITS+="$COMMIT\n"
              continue
            fi
            echo "‚úÖ Signature fingerprint matches imported key"

            echo "$SIG_OUT" | grep -q "Good signature from" || {
              echo "‚ùå Signature not valid for $COMMIT"; FAIL_CNT=$((FAIL_CNT+1)); FAIL_LOG+="- $COMMIT: signature invalid\n"; FAIL_COMMITS+="$COMMIT\n"; continue; }

            # 2) Verify coverage.sig hash at that revision
            if ! git cat-file -e "$COMMIT:badges/coverage.sig" 2>/dev/null; then
              echo "‚ùå badges/coverage.sig missing at $COMMIT"
              FAIL_CNT=$((FAIL_CNT+1))
              FAIL_LOG+="- $COMMIT: coverage.sig missing\n"
              FAIL_COMMITS+="$COMMIT\n"
              continue
            fi
            TMP=$(mktemp)
            git show "$COMMIT:badges/coverage.sig" > "$TMP"
            ACTUAL=$(sha256sum "$TMP" | awk '{print $1}')
            rm -f "$TMP"
            if [ "$ACTUAL" != "$EXPECTED" ]; then
              echo "‚ùå coverage.sig SHA256 mismatch (expected $EXPECTED, got $ACTUAL)"
              FAIL_CNT=$((FAIL_CNT+1))
              FAIL_LOG+="- $COMMIT: coverage.sig hash mismatch\n"
              FAIL_COMMITS+="$COMMIT\n"
              continue
            fi
            echo "‚úÖ coverage.sig hash matches versions.json entry"

            PASS_CNT=$((PASS_CNT+1))
          done

          echo "pass=$PASS_CNT" >> $GITHUB_OUTPUT
          echo "fail=$FAIL_CNT" >> $GITHUB_OUTPUT
          echo "checked=$CHECKED" >> $GITHUB_OUTPUT
          # Preserve detailed failure list (may be empty)
          echo "fail_log<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAIL_LOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "fail_commits<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAIL_COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Step summary
          echo "### üîé Provenance Audit Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Checked: $CHECKED" >> $GITHUB_STEP_SUMMARY
          echo "- Verified: $PASS_CNT" >> $GITHUB_STEP_SUMMARY
          echo "- Failed: $FAIL_CNT" >> $GITHUB_STEP_SUMMARY
          if [ "$FAIL_CNT" -gt 0 ]; then
            echo "\n#### Failures" >> $GITHUB_STEP_SUMMARY
            echo -e "$FAIL_LOG" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Open or update drift issue on failures
        if: ${{ steps.audit.outputs.fail && steps.audit.outputs.fail != '0' }}
        id: issue
        env:
          FAIL_LOG: ${{ steps.audit.outputs.fail_log }}
        run: |
          TITLE="Provenance drift detected"
          # Find existing open issue with same title
          EXISTING=$(curl -s -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/issues?state=open\&per_page=100 | \
            jq -r --arg t "$TITLE" '.[] | select(.title==$t) | .number' | head -n1)
          if [ -n "$EXISTING" ]; then
            echo "Existing issue #$EXISTING found. Appending comment."
            BODY="New failures detected by scheduled audit:\n\n${FAIL_LOG}"
            curl -s -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/$EXISTING/comments \
              -d "$(jq -nc --arg b "$BODY" '{body:$b}')"
            echo "issue_url=https://github.com/${{ github.repository }}/issues/$EXISTING" >> $GITHUB_OUTPUT
          else
            echo "Creating new issue: $TITLE"
            BODY="The scheduled provenance audit detected the following failures:\n\n${FAIL_LOG}"
            RESP=$(curl -s -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              https://api.github.com/repos/${{ github.repository }}/issues \
              -d "$(jq -nc --arg t "$TITLE" --arg b "$BODY" '{title:$t, body:$b}')")
            URL=$(echo "$RESP" | jq -r '.html_url')
            echo "issue_url=$URL" >> $GITHUB_OUTPUT
          fi

      - name: Auto-remediation (regenerate badge)
        if: ${{ steps.audit.outputs.fail && steps.audit.outputs.fail != '0' }}
        env:
          FAIL_COMMITS: ${{ steps.audit.outputs.fail_commits }}
        run: |
          echo "Triggering coverage_badge.yml via workflow_dispatch for remediation"
          curl -s -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/coverage_badge.yml/dispatches \
            -d '{"ref":"main"}'
          # Log per-commit remediation note
          echo "\n#### Auto-remediation" >> $GITHUB_STEP_SUMMARY
          while IFS= read -r c; do
            [ -n "$c" ] || continue
            echo "üõ†Ô∏è Auto-remediation triggered for $c" | tee -a $GITHUB_STEP_SUMMARY
          done <<< "$FAIL_COMMITS"

      - name: Generate executive audit summary
        run: |
          mkdir -p reports
          TS=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          CHECKED=${{ steps.audit.outputs.checked || 0 }}
          PASSED=${{ steps.audit.outputs.pass || 0 }}
          FAILED=${{ steps.audit.outputs.fail || 0 }}
          REMEDIATED=${{ steps.audit.outputs.fail || 0 }}
          ISSUE_URL=${{ steps.issue.outputs.issue_url || '' }}
          WF_LINK="https://github.com/${{ github.repository }}/actions/workflows/coverage_badge.yml"
          STATUS=$([ "$FAILED" -gt 0 ] && echo "ATTENTION REQUIRED" || echo "PASS")
          {
            echo "# Weekly Provenance Audit Summary"
            echo
            echo "- Timestamp: $TS"
            echo "- Auditor: GitHub Actions bot"
            echo "- Commits checked: $CHECKED"
            echo "- Passed: $PASSED"
            echo "- Failed: $FAILED"
            echo "- Remediated: $REMEDIATED"
            echo "- Issue: ${ISSUE_URL:-N/A}"
            echo "- Workflow: $WF_LINK"
            echo "- Overall Status: $STATUS"
          } > reports/audit_summary.md
          # Append dashboard link into step summary now (generated next)
          echo "\n[Provenance Dashboard](reports/provenance_dashboard.html)" >> $GITHUB_STEP_SUMMARY

      - name: Generate provenance insights dashboard
        run: |
          python scripts/workflow_utils/generate_provenance_dashboard.py

      - name: Commit executive audit summary
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add reports/audit_summary.md reports/provenance_dashboard.html
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "ci: update provenance dashboard and weekly audit summary."
            git push
          fi
