name: Audit Provenance History

on:
  schedule:
    - cron: "0 5 * * 0"  # Sundays at 05:00 UTC

jobs:
  audit-history:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq and gnupg
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq gnupg
          jq --version
          gpg --version

      - name: Import badge public key
        id: pubkey
        run: |
          if [ ! -f .github/public_keys/badge_signing.pub ]; then
            echo "Public key not found at .github/public_keys/badge_signing.pub" >&2
            exit 1
          fi
          gpg --import .github/public_keys/badge_signing.pub
          PUB_FPR=$(gpg --show-keys --with-colons .github/public_keys/badge_signing.pub | awk -F: '/^fpr:/{print $10; exit}')
          PUB_FPR_CLEAN=$(echo "$PUB_FPR" | tr -d ' ')
          echo "Imported public key fingerprint: $PUB_FPR"  # full forensics log
          echo "pub_fpr=$PUB_FPR_CLEAN" >> $GITHUB_OUTPUT

      - name: Audit last 10 provenance entries
        id: audit
        env:
          PUB_FPR: ${{ steps.pubkey.outputs.pub_fpr }}
        run: |
          set -e
          if [ ! -f reports/history/versions.json ]; then
            echo "versions.json not found at reports/history/versions.json" >&2
            echo "summary<<EOF" >> $GITHUB_OUTPUT
            echo "No versions.json present; nothing to audit." >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Prepare entries (commit and expected sig hash) from various possible schemas
          mapfile -t ENTRIES < <(jq -r '
            ((.versions // .history // .entries // .) | (if type=="array" then . else [] end))
            | (if length>10 then .[-10:] else . end)
            | map({c: (.commit // .sha // .hash // .rev // .revision // .id), h: (.coverage_badge_hash // .coverageHash // .coverage_sig_sha256)})
            | map(select(.c!=null and .h!=null))
            | .[] | "\(.c) \(.h)"' reports/history/versions.json)

          PASS_CNT=0
          FAIL_CNT=0
          FAIL_LOG=""

          for line in "${ENTRIES[@]}"; do
            COMMIT=$(echo "$line" | awk '{print $1}')
            EXPECTED=$(echo "$line" | awk '{print $2}')
            echo "\nAuditing commit $COMMIT ..."

            # 1) Verify signature matches imported key
            SIG_OUT=$(git log -1 --show-signature "$COMMIT" 2>&1 || true)
            echo "$SIG_OUT"
            COMMIT_FPR=$(echo "$SIG_OUT" | sed -n -E 's/^gpg: Primary key fingerprint: (.*)/\1/p' | head -n1 | tr -d ' ')
            if [ -z "$COMMIT_FPR" ]; then
              echo "âŒ No GPG fingerprint found in signature output for $COMMIT"
              FAIL_CNT=$((FAIL_CNT+1))
              FAIL_LOG+="- $COMMIT: missing signature or fingerprint\n"
              continue
            fi
            if [ "$COMMIT_FPR" != "$PUB_FPR" ]; then
              echo "âŒ Fingerprint mismatch: commit uses $COMMIT_FPR, expected $PUB_FPR"
              FAIL_CNT=$((FAIL_CNT+1))
              FAIL_LOG+="- $COMMIT: fingerprint mismatch\n"
              continue
            fi
            echo "âœ… Signature fingerprint matches imported key"

            echo "$SIG_OUT" | grep -q "Good signature from" || {
              echo "âŒ Signature not valid for $COMMIT"; FAIL_CNT=$((FAIL_CNT+1)); FAIL_LOG+="- $COMMIT: signature invalid\n"; continue; }

            # 2) Verify coverage.sig hash at that revision
            if ! git cat-file -e "$COMMIT:badges/coverage.sig" 2>/dev/null; then
              echo "âŒ badges/coverage.sig missing at $COMMIT"
              FAIL_CNT=$((FAIL_CNT+1))
              FAIL_LOG+="- $COMMIT: coverage.sig missing\n"
              continue
            fi
            TMP=$(mktemp)
            git show "$COMMIT:badges/coverage.sig" > "$TMP"
            ACTUAL=$(sha256sum "$TMP" | awk '{print $1}')
            rm -f "$TMP"
            if [ "$ACTUAL" != "$EXPECTED" ]; then
              echo "âŒ coverage.sig SHA256 mismatch (expected $EXPECTED, got $ACTUAL)"
              FAIL_CNT=$((FAIL_CNT+1))
              FAIL_LOG+="- $COMMIT: coverage.sig hash mismatch\n"
              continue
            fi
            echo "âœ… coverage.sig hash matches versions.json entry"

            PASS_CNT=$((PASS_CNT+1))
          done

          echo "pass=$PASS_CNT" >> $GITHUB_OUTPUT
          echo "fail=$FAIL_CNT" >> $GITHUB_OUTPUT
          # Preserve detailed failure list (may be empty)
          echo "fail_log<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAIL_LOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Step summary
          echo "### ðŸ”Ž Provenance Audit Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Verified: $PASS_CNT" >> $GITHUB_STEP_SUMMARY
          echo "- Failed: $FAIL_CNT" >> $GITHUB_STEP_SUMMARY
          if [ "$FAIL_CNT" -gt 0 ]; then
            echo "\n#### Failures" >> $GITHUB_STEP_SUMMARY
            echo -e "$FAIL_LOG" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Open issue on failures
        if: ${{ steps.audit.outputs.fail && steps.audit.outputs.fail != '0' }}
        env:
          FAIL_LOG: ${{ steps.audit.outputs.fail_log }}
        run: |
          TITLE="Provenance drift detected"
          BODY="The scheduled provenance audit detected the following failures:\n\n${FAIL_LOG}"
          echo "Creating issue: $TITLE"
          curl -s -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/issues \
            -d "$(jq -nc --arg t "$TITLE" --arg b "$BODY" '{title:$t, body:$b}')"
